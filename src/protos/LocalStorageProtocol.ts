// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: LocalStorageProtocol.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export interface SessionStructure {
  sessionVersion?: number | undefined;
  localIdentityPublic?: Uint8Array | undefined;
  remoteIdentityPublic?: Uint8Array | undefined;
  rootKey?: Uint8Array | undefined;
  previousCounter?: number | undefined;
  senderChain?: SessionStructure_Chain | undefined;
  receiverChains: SessionStructure_Chain[];
  pendingKeyExchange?: SessionStructure_PendingKeyExchange | undefined;
  pendingPreKey?: SessionStructure_PendingPreKey | undefined;
  remoteRegistrationId?: number | undefined;
  localRegistrationId?: number | undefined;
  needsRefresh?: boolean | undefined;
  aliceBaseKey?: Uint8Array | undefined;
}

export interface SessionStructure_Chain {
  senderRatchetKey?: Uint8Array | undefined;
  senderRatchetKeyPrivate?: Uint8Array | undefined;
  chainKey?: SessionStructure_Chain_ChainKey | undefined;
  messageKeys: SessionStructure_Chain_MessageKey[];
}

export interface SessionStructure_Chain_ChainKey {
  index?: number | undefined;
  key?: Uint8Array | undefined;
}

export interface SessionStructure_Chain_MessageKey {
  index?: number | undefined;
  cipherKey?: Uint8Array | undefined;
  macKey?: Uint8Array | undefined;
  iv?: Uint8Array | undefined;
}

export interface SessionStructure_PendingKeyExchange {
  sequence?: number | undefined;
  localBaseKey?: Uint8Array | undefined;
  localBaseKeyPrivate?: Uint8Array | undefined;
  localRatchetKey?: Uint8Array | undefined;
  localRatchetKeyPrivate?: Uint8Array | undefined;
  localIdentityKey?: Uint8Array | undefined;
  localIdentityKeyPrivate?: Uint8Array | undefined;
}

export interface SessionStructure_PendingPreKey {
  preKeyId?: number | undefined;
  signedPreKeyId?: number | undefined;
  baseKey?: Uint8Array | undefined;
}

export interface RecordStructure {
  currentSession?: SessionStructure | undefined;
  previousSessions: SessionStructure[];
}

export interface PreKeyRecordStructure {
  id?: number | undefined;
  publicKey?: Uint8Array | undefined;
  privateKey?: Uint8Array | undefined;
}

export interface SignedPreKeyRecordStructure {
  id?: number | undefined;
  publicKey?: Uint8Array | undefined;
  privateKey?: Uint8Array | undefined;
  signature?: Uint8Array | undefined;
  timestamp?: number | undefined;
}

export interface IdentityKeyPairStructure {
  publicKey?: Uint8Array | undefined;
  privateKey?: Uint8Array | undefined;
}

export interface SenderKeyStateStructure {
  senderKeyId?: number | undefined;
  senderChainKey?: SenderKeyStateStructure_SenderChainKey | undefined;
  senderSigningKey?: SenderKeyStateStructure_SenderSigningKey | undefined;
  senderMessageKeys: SenderKeyStateStructure_SenderMessageKey[];
}

export interface SenderKeyStateStructure_SenderChainKey {
  iteration?: number | undefined;
  seed?: Uint8Array | undefined;
}

export interface SenderKeyStateStructure_SenderMessageKey {
  iteration?: number | undefined;
  seed?: Uint8Array | undefined;
}

export interface SenderKeyStateStructure_SenderSigningKey {
  public?: Uint8Array | undefined;
  private?: Uint8Array | undefined;
}

export interface SenderKeyRecordStructure {
  senderKeyStates: SenderKeyStateStructure[];
}

function createBaseSessionStructure(): SessionStructure {
  return {
    sessionVersion: undefined,
    localIdentityPublic: undefined,
    remoteIdentityPublic: undefined,
    rootKey: undefined,
    previousCounter: undefined,
    senderChain: undefined,
    receiverChains: [],
    pendingKeyExchange: undefined,
    pendingPreKey: undefined,
    remoteRegistrationId: undefined,
    localRegistrationId: undefined,
    needsRefresh: undefined,
    aliceBaseKey: undefined,
  };
}

export const SessionStructure: MessageFns<SessionStructure> = {
  encode(message: SessionStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionVersion !== undefined) {
      writer.uint32(8).uint32(message.sessionVersion);
    }
    if (message.localIdentityPublic !== undefined) {
      writer.uint32(18).bytes(message.localIdentityPublic);
    }
    if (message.remoteIdentityPublic !== undefined) {
      writer.uint32(26).bytes(message.remoteIdentityPublic);
    }
    if (message.rootKey !== undefined) {
      writer.uint32(34).bytes(message.rootKey);
    }
    if (message.previousCounter !== undefined) {
      writer.uint32(40).uint32(message.previousCounter);
    }
    if (message.senderChain !== undefined) {
      SessionStructure_Chain.encode(message.senderChain, writer.uint32(50).fork()).join();
    }
    for (const v of message.receiverChains) {
      SessionStructure_Chain.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.pendingKeyExchange !== undefined) {
      SessionStructure_PendingKeyExchange.encode(message.pendingKeyExchange, writer.uint32(66).fork()).join();
    }
    if (message.pendingPreKey !== undefined) {
      SessionStructure_PendingPreKey.encode(message.pendingPreKey, writer.uint32(74).fork()).join();
    }
    if (message.remoteRegistrationId !== undefined) {
      writer.uint32(80).uint32(message.remoteRegistrationId);
    }
    if (message.localRegistrationId !== undefined) {
      writer.uint32(88).uint32(message.localRegistrationId);
    }
    if (message.needsRefresh !== undefined) {
      writer.uint32(96).bool(message.needsRefresh);
    }
    if (message.aliceBaseKey !== undefined) {
      writer.uint32(106).bytes(message.aliceBaseKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.localIdentityPublic = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remoteIdentityPublic = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rootKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.previousCounter = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.senderChain = SessionStructure_Chain.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.receiverChains.push(SessionStructure_Chain.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pendingKeyExchange = SessionStructure_PendingKeyExchange.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pendingPreKey = SessionStructure_PendingPreKey.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.remoteRegistrationId = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.localRegistrationId = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.needsRefresh = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.aliceBaseKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStructure {
    return {
      sessionVersion: isSet(object.sessionVersion) ? globalThis.Number(object.sessionVersion) : undefined,
      localIdentityPublic: isSet(object.localIdentityPublic) ? bytesFromBase64(object.localIdentityPublic) : undefined,
      remoteIdentityPublic: isSet(object.remoteIdentityPublic)
        ? bytesFromBase64(object.remoteIdentityPublic)
        : undefined,
      rootKey: isSet(object.rootKey) ? bytesFromBase64(object.rootKey) : undefined,
      previousCounter: isSet(object.previousCounter) ? globalThis.Number(object.previousCounter) : undefined,
      senderChain: isSet(object.senderChain) ? SessionStructure_Chain.fromJSON(object.senderChain) : undefined,
      receiverChains: globalThis.Array.isArray(object?.receiverChains)
        ? object.receiverChains.map((e: any) => SessionStructure_Chain.fromJSON(e))
        : [],
      pendingKeyExchange: isSet(object.pendingKeyExchange)
        ? SessionStructure_PendingKeyExchange.fromJSON(object.pendingKeyExchange)
        : undefined,
      pendingPreKey: isSet(object.pendingPreKey)
        ? SessionStructure_PendingPreKey.fromJSON(object.pendingPreKey)
        : undefined,
      remoteRegistrationId: isSet(object.remoteRegistrationId)
        ? globalThis.Number(object.remoteRegistrationId)
        : undefined,
      localRegistrationId: isSet(object.localRegistrationId)
        ? globalThis.Number(object.localRegistrationId)
        : undefined,
      needsRefresh: isSet(object.needsRefresh) ? globalThis.Boolean(object.needsRefresh) : undefined,
      aliceBaseKey: isSet(object.aliceBaseKey) ? bytesFromBase64(object.aliceBaseKey) : undefined,
    };
  },

  toJSON(message: SessionStructure): unknown {
    const obj: any = {};
    if (message.sessionVersion !== undefined) {
      obj.sessionVersion = Math.round(message.sessionVersion);
    }
    if (message.localIdentityPublic !== undefined) {
      obj.localIdentityPublic = base64FromBytes(message.localIdentityPublic);
    }
    if (message.remoteIdentityPublic !== undefined) {
      obj.remoteIdentityPublic = base64FromBytes(message.remoteIdentityPublic);
    }
    if (message.rootKey !== undefined) {
      obj.rootKey = base64FromBytes(message.rootKey);
    }
    if (message.previousCounter !== undefined) {
      obj.previousCounter = Math.round(message.previousCounter);
    }
    if (message.senderChain !== undefined) {
      obj.senderChain = SessionStructure_Chain.toJSON(message.senderChain);
    }
    if (message.receiverChains?.length) {
      obj.receiverChains = message.receiverChains.map((e) => SessionStructure_Chain.toJSON(e));
    }
    if (message.pendingKeyExchange !== undefined) {
      obj.pendingKeyExchange = SessionStructure_PendingKeyExchange.toJSON(message.pendingKeyExchange);
    }
    if (message.pendingPreKey !== undefined) {
      obj.pendingPreKey = SessionStructure_PendingPreKey.toJSON(message.pendingPreKey);
    }
    if (message.remoteRegistrationId !== undefined) {
      obj.remoteRegistrationId = Math.round(message.remoteRegistrationId);
    }
    if (message.localRegistrationId !== undefined) {
      obj.localRegistrationId = Math.round(message.localRegistrationId);
    }
    if (message.needsRefresh !== undefined) {
      obj.needsRefresh = message.needsRefresh;
    }
    if (message.aliceBaseKey !== undefined) {
      obj.aliceBaseKey = base64FromBytes(message.aliceBaseKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStructure>, I>>(base?: I): SessionStructure {
    return SessionStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStructure>, I>>(object: I): SessionStructure {
    const message = createBaseSessionStructure();
    message.sessionVersion = object.sessionVersion ?? undefined;
    message.localIdentityPublic = object.localIdentityPublic ?? undefined;
    message.remoteIdentityPublic = object.remoteIdentityPublic ?? undefined;
    message.rootKey = object.rootKey ?? undefined;
    message.previousCounter = object.previousCounter ?? undefined;
    message.senderChain = (object.senderChain !== undefined && object.senderChain !== null)
      ? SessionStructure_Chain.fromPartial(object.senderChain)
      : undefined;
    message.receiverChains = object.receiverChains?.map((e) => SessionStructure_Chain.fromPartial(e)) || [];
    message.pendingKeyExchange = (object.pendingKeyExchange !== undefined && object.pendingKeyExchange !== null)
      ? SessionStructure_PendingKeyExchange.fromPartial(object.pendingKeyExchange)
      : undefined;
    message.pendingPreKey = (object.pendingPreKey !== undefined && object.pendingPreKey !== null)
      ? SessionStructure_PendingPreKey.fromPartial(object.pendingPreKey)
      : undefined;
    message.remoteRegistrationId = object.remoteRegistrationId ?? undefined;
    message.localRegistrationId = object.localRegistrationId ?? undefined;
    message.needsRefresh = object.needsRefresh ?? undefined;
    message.aliceBaseKey = object.aliceBaseKey ?? undefined;
    return message;
  },
};

function createBaseSessionStructure_Chain(): SessionStructure_Chain {
  return { senderRatchetKey: undefined, senderRatchetKeyPrivate: undefined, chainKey: undefined, messageKeys: [] };
}

export const SessionStructure_Chain: MessageFns<SessionStructure_Chain> = {
  encode(message: SessionStructure_Chain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.senderRatchetKey !== undefined) {
      writer.uint32(10).bytes(message.senderRatchetKey);
    }
    if (message.senderRatchetKeyPrivate !== undefined) {
      writer.uint32(18).bytes(message.senderRatchetKeyPrivate);
    }
    if (message.chainKey !== undefined) {
      SessionStructure_Chain_ChainKey.encode(message.chainKey, writer.uint32(26).fork()).join();
    }
    for (const v of message.messageKeys) {
      SessionStructure_Chain_MessageKey.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStructure_Chain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStructure_Chain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.senderRatchetKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderRatchetKeyPrivate = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainKey = SessionStructure_Chain_ChainKey.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.messageKeys.push(SessionStructure_Chain_MessageKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStructure_Chain {
    return {
      senderRatchetKey: isSet(object.senderRatchetKey) ? bytesFromBase64(object.senderRatchetKey) : undefined,
      senderRatchetKeyPrivate: isSet(object.senderRatchetKeyPrivate)
        ? bytesFromBase64(object.senderRatchetKeyPrivate)
        : undefined,
      chainKey: isSet(object.chainKey) ? SessionStructure_Chain_ChainKey.fromJSON(object.chainKey) : undefined,
      messageKeys: globalThis.Array.isArray(object?.messageKeys)
        ? object.messageKeys.map((e: any) => SessionStructure_Chain_MessageKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SessionStructure_Chain): unknown {
    const obj: any = {};
    if (message.senderRatchetKey !== undefined) {
      obj.senderRatchetKey = base64FromBytes(message.senderRatchetKey);
    }
    if (message.senderRatchetKeyPrivate !== undefined) {
      obj.senderRatchetKeyPrivate = base64FromBytes(message.senderRatchetKeyPrivate);
    }
    if (message.chainKey !== undefined) {
      obj.chainKey = SessionStructure_Chain_ChainKey.toJSON(message.chainKey);
    }
    if (message.messageKeys?.length) {
      obj.messageKeys = message.messageKeys.map((e) => SessionStructure_Chain_MessageKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStructure_Chain>, I>>(base?: I): SessionStructure_Chain {
    return SessionStructure_Chain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStructure_Chain>, I>>(object: I): SessionStructure_Chain {
    const message = createBaseSessionStructure_Chain();
    message.senderRatchetKey = object.senderRatchetKey ?? undefined;
    message.senderRatchetKeyPrivate = object.senderRatchetKeyPrivate ?? undefined;
    message.chainKey = (object.chainKey !== undefined && object.chainKey !== null)
      ? SessionStructure_Chain_ChainKey.fromPartial(object.chainKey)
      : undefined;
    message.messageKeys = object.messageKeys?.map((e) => SessionStructure_Chain_MessageKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionStructure_Chain_ChainKey(): SessionStructure_Chain_ChainKey {
  return { index: undefined, key: undefined };
}

export const SessionStructure_Chain_ChainKey: MessageFns<SessionStructure_Chain_ChainKey> = {
  encode(message: SessionStructure_Chain_ChainKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== undefined) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.key !== undefined) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStructure_Chain_ChainKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStructure_Chain_ChainKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStructure_Chain_ChainKey {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : undefined,
      key: isSet(object.key) ? bytesFromBase64(object.key) : undefined,
    };
  },

  toJSON(message: SessionStructure_Chain_ChainKey): unknown {
    const obj: any = {};
    if (message.index !== undefined) {
      obj.index = Math.round(message.index);
    }
    if (message.key !== undefined) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStructure_Chain_ChainKey>, I>>(base?: I): SessionStructure_Chain_ChainKey {
    return SessionStructure_Chain_ChainKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStructure_Chain_ChainKey>, I>>(
    object: I,
  ): SessionStructure_Chain_ChainKey {
    const message = createBaseSessionStructure_Chain_ChainKey();
    message.index = object.index ?? undefined;
    message.key = object.key ?? undefined;
    return message;
  },
};

function createBaseSessionStructure_Chain_MessageKey(): SessionStructure_Chain_MessageKey {
  return { index: undefined, cipherKey: undefined, macKey: undefined, iv: undefined };
}

export const SessionStructure_Chain_MessageKey: MessageFns<SessionStructure_Chain_MessageKey> = {
  encode(message: SessionStructure_Chain_MessageKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== undefined) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.cipherKey !== undefined) {
      writer.uint32(18).bytes(message.cipherKey);
    }
    if (message.macKey !== undefined) {
      writer.uint32(26).bytes(message.macKey);
    }
    if (message.iv !== undefined) {
      writer.uint32(34).bytes(message.iv);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStructure_Chain_MessageKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStructure_Chain_MessageKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cipherKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.macKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStructure_Chain_MessageKey {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : undefined,
      cipherKey: isSet(object.cipherKey) ? bytesFromBase64(object.cipherKey) : undefined,
      macKey: isSet(object.macKey) ? bytesFromBase64(object.macKey) : undefined,
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : undefined,
    };
  },

  toJSON(message: SessionStructure_Chain_MessageKey): unknown {
    const obj: any = {};
    if (message.index !== undefined) {
      obj.index = Math.round(message.index);
    }
    if (message.cipherKey !== undefined) {
      obj.cipherKey = base64FromBytes(message.cipherKey);
    }
    if (message.macKey !== undefined) {
      obj.macKey = base64FromBytes(message.macKey);
    }
    if (message.iv !== undefined) {
      obj.iv = base64FromBytes(message.iv);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStructure_Chain_MessageKey>, I>>(
    base?: I,
  ): SessionStructure_Chain_MessageKey {
    return SessionStructure_Chain_MessageKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStructure_Chain_MessageKey>, I>>(
    object: I,
  ): SessionStructure_Chain_MessageKey {
    const message = createBaseSessionStructure_Chain_MessageKey();
    message.index = object.index ?? undefined;
    message.cipherKey = object.cipherKey ?? undefined;
    message.macKey = object.macKey ?? undefined;
    message.iv = object.iv ?? undefined;
    return message;
  },
};

function createBaseSessionStructure_PendingKeyExchange(): SessionStructure_PendingKeyExchange {
  return {
    sequence: undefined,
    localBaseKey: undefined,
    localBaseKeyPrivate: undefined,
    localRatchetKey: undefined,
    localRatchetKeyPrivate: undefined,
    localIdentityKey: undefined,
    localIdentityKeyPrivate: undefined,
  };
}

export const SessionStructure_PendingKeyExchange: MessageFns<SessionStructure_PendingKeyExchange> = {
  encode(message: SessionStructure_PendingKeyExchange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequence !== undefined) {
      writer.uint32(8).uint32(message.sequence);
    }
    if (message.localBaseKey !== undefined) {
      writer.uint32(18).bytes(message.localBaseKey);
    }
    if (message.localBaseKeyPrivate !== undefined) {
      writer.uint32(26).bytes(message.localBaseKeyPrivate);
    }
    if (message.localRatchetKey !== undefined) {
      writer.uint32(34).bytes(message.localRatchetKey);
    }
    if (message.localRatchetKeyPrivate !== undefined) {
      writer.uint32(42).bytes(message.localRatchetKeyPrivate);
    }
    if (message.localIdentityKey !== undefined) {
      writer.uint32(58).bytes(message.localIdentityKey);
    }
    if (message.localIdentityKeyPrivate !== undefined) {
      writer.uint32(66).bytes(message.localIdentityKeyPrivate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStructure_PendingKeyExchange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStructure_PendingKeyExchange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sequence = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.localBaseKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.localBaseKeyPrivate = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.localRatchetKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.localRatchetKeyPrivate = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.localIdentityKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.localIdentityKeyPrivate = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStructure_PendingKeyExchange {
    return {
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : undefined,
      localBaseKey: isSet(object.localBaseKey) ? bytesFromBase64(object.localBaseKey) : undefined,
      localBaseKeyPrivate: isSet(object.localBaseKeyPrivate) ? bytesFromBase64(object.localBaseKeyPrivate) : undefined,
      localRatchetKey: isSet(object.localRatchetKey) ? bytesFromBase64(object.localRatchetKey) : undefined,
      localRatchetKeyPrivate: isSet(object.localRatchetKeyPrivate)
        ? bytesFromBase64(object.localRatchetKeyPrivate)
        : undefined,
      localIdentityKey: isSet(object.localIdentityKey) ? bytesFromBase64(object.localIdentityKey) : undefined,
      localIdentityKeyPrivate: isSet(object.localIdentityKeyPrivate)
        ? bytesFromBase64(object.localIdentityKeyPrivate)
        : undefined,
    };
  },

  toJSON(message: SessionStructure_PendingKeyExchange): unknown {
    const obj: any = {};
    if (message.sequence !== undefined) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.localBaseKey !== undefined) {
      obj.localBaseKey = base64FromBytes(message.localBaseKey);
    }
    if (message.localBaseKeyPrivate !== undefined) {
      obj.localBaseKeyPrivate = base64FromBytes(message.localBaseKeyPrivate);
    }
    if (message.localRatchetKey !== undefined) {
      obj.localRatchetKey = base64FromBytes(message.localRatchetKey);
    }
    if (message.localRatchetKeyPrivate !== undefined) {
      obj.localRatchetKeyPrivate = base64FromBytes(message.localRatchetKeyPrivate);
    }
    if (message.localIdentityKey !== undefined) {
      obj.localIdentityKey = base64FromBytes(message.localIdentityKey);
    }
    if (message.localIdentityKeyPrivate !== undefined) {
      obj.localIdentityKeyPrivate = base64FromBytes(message.localIdentityKeyPrivate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStructure_PendingKeyExchange>, I>>(
    base?: I,
  ): SessionStructure_PendingKeyExchange {
    return SessionStructure_PendingKeyExchange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStructure_PendingKeyExchange>, I>>(
    object: I,
  ): SessionStructure_PendingKeyExchange {
    const message = createBaseSessionStructure_PendingKeyExchange();
    message.sequence = object.sequence ?? undefined;
    message.localBaseKey = object.localBaseKey ?? undefined;
    message.localBaseKeyPrivate = object.localBaseKeyPrivate ?? undefined;
    message.localRatchetKey = object.localRatchetKey ?? undefined;
    message.localRatchetKeyPrivate = object.localRatchetKeyPrivate ?? undefined;
    message.localIdentityKey = object.localIdentityKey ?? undefined;
    message.localIdentityKeyPrivate = object.localIdentityKeyPrivate ?? undefined;
    return message;
  },
};

function createBaseSessionStructure_PendingPreKey(): SessionStructure_PendingPreKey {
  return { preKeyId: undefined, signedPreKeyId: undefined, baseKey: undefined };
}

export const SessionStructure_PendingPreKey: MessageFns<SessionStructure_PendingPreKey> = {
  encode(message: SessionStructure_PendingPreKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preKeyId !== undefined) {
      writer.uint32(8).uint32(message.preKeyId);
    }
    if (message.signedPreKeyId !== undefined) {
      writer.uint32(24).int32(message.signedPreKeyId);
    }
    if (message.baseKey !== undefined) {
      writer.uint32(18).bytes(message.baseKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStructure_PendingPreKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStructure_PendingPreKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.preKeyId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signedPreKeyId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStructure_PendingPreKey {
    return {
      preKeyId: isSet(object.preKeyId) ? globalThis.Number(object.preKeyId) : undefined,
      signedPreKeyId: isSet(object.signedPreKeyId) ? globalThis.Number(object.signedPreKeyId) : undefined,
      baseKey: isSet(object.baseKey) ? bytesFromBase64(object.baseKey) : undefined,
    };
  },

  toJSON(message: SessionStructure_PendingPreKey): unknown {
    const obj: any = {};
    if (message.preKeyId !== undefined) {
      obj.preKeyId = Math.round(message.preKeyId);
    }
    if (message.signedPreKeyId !== undefined) {
      obj.signedPreKeyId = Math.round(message.signedPreKeyId);
    }
    if (message.baseKey !== undefined) {
      obj.baseKey = base64FromBytes(message.baseKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStructure_PendingPreKey>, I>>(base?: I): SessionStructure_PendingPreKey {
    return SessionStructure_PendingPreKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStructure_PendingPreKey>, I>>(
    object: I,
  ): SessionStructure_PendingPreKey {
    const message = createBaseSessionStructure_PendingPreKey();
    message.preKeyId = object.preKeyId ?? undefined;
    message.signedPreKeyId = object.signedPreKeyId ?? undefined;
    message.baseKey = object.baseKey ?? undefined;
    return message;
  },
};

function createBaseRecordStructure(): RecordStructure {
  return { currentSession: undefined, previousSessions: [] };
}

export const RecordStructure: MessageFns<RecordStructure> = {
  encode(message: RecordStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentSession !== undefined) {
      SessionStructure.encode(message.currentSession, writer.uint32(10).fork()).join();
    }
    for (const v of message.previousSessions) {
      SessionStructure.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currentSession = SessionStructure.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousSessions.push(SessionStructure.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordStructure {
    return {
      currentSession: isSet(object.currentSession) ? SessionStructure.fromJSON(object.currentSession) : undefined,
      previousSessions: globalThis.Array.isArray(object?.previousSessions)
        ? object.previousSessions.map((e: any) => SessionStructure.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RecordStructure): unknown {
    const obj: any = {};
    if (message.currentSession !== undefined) {
      obj.currentSession = SessionStructure.toJSON(message.currentSession);
    }
    if (message.previousSessions?.length) {
      obj.previousSessions = message.previousSessions.map((e) => SessionStructure.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordStructure>, I>>(base?: I): RecordStructure {
    return RecordStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordStructure>, I>>(object: I): RecordStructure {
    const message = createBaseRecordStructure();
    message.currentSession = (object.currentSession !== undefined && object.currentSession !== null)
      ? SessionStructure.fromPartial(object.currentSession)
      : undefined;
    message.previousSessions = object.previousSessions?.map((e) => SessionStructure.fromPartial(e)) || [];
    return message;
  },
};

function createBasePreKeyRecordStructure(): PreKeyRecordStructure {
  return { id: undefined, publicKey: undefined, privateKey: undefined };
}

export const PreKeyRecordStructure: MessageFns<PreKeyRecordStructure> = {
  encode(message: PreKeyRecordStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.publicKey !== undefined) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.privateKey !== undefined) {
      writer.uint32(26).bytes(message.privateKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyRecordStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyRecordStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.privateKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyRecordStructure {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : undefined,
      privateKey: isSet(object.privateKey) ? bytesFromBase64(object.privateKey) : undefined,
    };
  },

  toJSON(message: PreKeyRecordStructure): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.privateKey !== undefined) {
      obj.privateKey = base64FromBytes(message.privateKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyRecordStructure>, I>>(base?: I): PreKeyRecordStructure {
    return PreKeyRecordStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyRecordStructure>, I>>(object: I): PreKeyRecordStructure {
    const message = createBasePreKeyRecordStructure();
    message.id = object.id ?? undefined;
    message.publicKey = object.publicKey ?? undefined;
    message.privateKey = object.privateKey ?? undefined;
    return message;
  },
};

function createBaseSignedPreKeyRecordStructure(): SignedPreKeyRecordStructure {
  return { id: undefined, publicKey: undefined, privateKey: undefined, signature: undefined, timestamp: undefined };
}

export const SignedPreKeyRecordStructure: MessageFns<SignedPreKeyRecordStructure> = {
  encode(message: SignedPreKeyRecordStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.publicKey !== undefined) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.privateKey !== undefined) {
      writer.uint32(26).bytes(message.privateKey);
    }
    if (message.signature !== undefined) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.timestamp !== undefined) {
      writer.uint32(41).fixed64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedPreKeyRecordStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedPreKeyRecordStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.privateKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.timestamp = longToNumber(reader.fixed64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedPreKeyRecordStructure {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : undefined,
      privateKey: isSet(object.privateKey) ? bytesFromBase64(object.privateKey) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : undefined,
    };
  },

  toJSON(message: SignedPreKeyRecordStructure): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.privateKey !== undefined) {
      obj.privateKey = base64FromBytes(message.privateKey);
    }
    if (message.signature !== undefined) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedPreKeyRecordStructure>, I>>(base?: I): SignedPreKeyRecordStructure {
    return SignedPreKeyRecordStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedPreKeyRecordStructure>, I>>(object: I): SignedPreKeyRecordStructure {
    const message = createBaseSignedPreKeyRecordStructure();
    message.id = object.id ?? undefined;
    message.publicKey = object.publicKey ?? undefined;
    message.privateKey = object.privateKey ?? undefined;
    message.signature = object.signature ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseIdentityKeyPairStructure(): IdentityKeyPairStructure {
  return { publicKey: undefined, privateKey: undefined };
}

export const IdentityKeyPairStructure: MessageFns<IdentityKeyPairStructure> = {
  encode(message: IdentityKeyPairStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== undefined) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.privateKey !== undefined) {
      writer.uint32(18).bytes(message.privateKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityKeyPairStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityKeyPairStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.privateKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityKeyPairStructure {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : undefined,
      privateKey: isSet(object.privateKey) ? bytesFromBase64(object.privateKey) : undefined,
    };
  },

  toJSON(message: IdentityKeyPairStructure): unknown {
    const obj: any = {};
    if (message.publicKey !== undefined) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.privateKey !== undefined) {
      obj.privateKey = base64FromBytes(message.privateKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdentityKeyPairStructure>, I>>(base?: I): IdentityKeyPairStructure {
    return IdentityKeyPairStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdentityKeyPairStructure>, I>>(object: I): IdentityKeyPairStructure {
    const message = createBaseIdentityKeyPairStructure();
    message.publicKey = object.publicKey ?? undefined;
    message.privateKey = object.privateKey ?? undefined;
    return message;
  },
};

function createBaseSenderKeyStateStructure(): SenderKeyStateStructure {
  return { senderKeyId: undefined, senderChainKey: undefined, senderSigningKey: undefined, senderMessageKeys: [] };
}

export const SenderKeyStateStructure: MessageFns<SenderKeyStateStructure> = {
  encode(message: SenderKeyStateStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.senderKeyId !== undefined) {
      writer.uint32(8).uint32(message.senderKeyId);
    }
    if (message.senderChainKey !== undefined) {
      SenderKeyStateStructure_SenderChainKey.encode(message.senderChainKey, writer.uint32(18).fork()).join();
    }
    if (message.senderSigningKey !== undefined) {
      SenderKeyStateStructure_SenderSigningKey.encode(message.senderSigningKey, writer.uint32(26).fork()).join();
    }
    for (const v of message.senderMessageKeys) {
      SenderKeyStateStructure_SenderMessageKey.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyStateStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyStateStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.senderKeyId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderChainKey = SenderKeyStateStructure_SenderChainKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.senderSigningKey = SenderKeyStateStructure_SenderSigningKey.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.senderMessageKeys.push(SenderKeyStateStructure_SenderMessageKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyStateStructure {
    return {
      senderKeyId: isSet(object.senderKeyId) ? globalThis.Number(object.senderKeyId) : undefined,
      senderChainKey: isSet(object.senderChainKey)
        ? SenderKeyStateStructure_SenderChainKey.fromJSON(object.senderChainKey)
        : undefined,
      senderSigningKey: isSet(object.senderSigningKey)
        ? SenderKeyStateStructure_SenderSigningKey.fromJSON(object.senderSigningKey)
        : undefined,
      senderMessageKeys: globalThis.Array.isArray(object?.senderMessageKeys)
        ? object.senderMessageKeys.map((e: any) => SenderKeyStateStructure_SenderMessageKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SenderKeyStateStructure): unknown {
    const obj: any = {};
    if (message.senderKeyId !== undefined) {
      obj.senderKeyId = Math.round(message.senderKeyId);
    }
    if (message.senderChainKey !== undefined) {
      obj.senderChainKey = SenderKeyStateStructure_SenderChainKey.toJSON(message.senderChainKey);
    }
    if (message.senderSigningKey !== undefined) {
      obj.senderSigningKey = SenderKeyStateStructure_SenderSigningKey.toJSON(message.senderSigningKey);
    }
    if (message.senderMessageKeys?.length) {
      obj.senderMessageKeys = message.senderMessageKeys.map((e) => SenderKeyStateStructure_SenderMessageKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyStateStructure>, I>>(base?: I): SenderKeyStateStructure {
    return SenderKeyStateStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyStateStructure>, I>>(object: I): SenderKeyStateStructure {
    const message = createBaseSenderKeyStateStructure();
    message.senderKeyId = object.senderKeyId ?? undefined;
    message.senderChainKey = (object.senderChainKey !== undefined && object.senderChainKey !== null)
      ? SenderKeyStateStructure_SenderChainKey.fromPartial(object.senderChainKey)
      : undefined;
    message.senderSigningKey = (object.senderSigningKey !== undefined && object.senderSigningKey !== null)
      ? SenderKeyStateStructure_SenderSigningKey.fromPartial(object.senderSigningKey)
      : undefined;
    message.senderMessageKeys =
      object.senderMessageKeys?.map((e) => SenderKeyStateStructure_SenderMessageKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSenderKeyStateStructure_SenderChainKey(): SenderKeyStateStructure_SenderChainKey {
  return { iteration: undefined, seed: undefined };
}

export const SenderKeyStateStructure_SenderChainKey: MessageFns<SenderKeyStateStructure_SenderChainKey> = {
  encode(message: SenderKeyStateStructure_SenderChainKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iteration !== undefined) {
      writer.uint32(8).uint32(message.iteration);
    }
    if (message.seed !== undefined) {
      writer.uint32(18).bytes(message.seed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyStateStructure_SenderChainKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyStateStructure_SenderChainKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iteration = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seed = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyStateStructure_SenderChainKey {
    return {
      iteration: isSet(object.iteration) ? globalThis.Number(object.iteration) : undefined,
      seed: isSet(object.seed) ? bytesFromBase64(object.seed) : undefined,
    };
  },

  toJSON(message: SenderKeyStateStructure_SenderChainKey): unknown {
    const obj: any = {};
    if (message.iteration !== undefined) {
      obj.iteration = Math.round(message.iteration);
    }
    if (message.seed !== undefined) {
      obj.seed = base64FromBytes(message.seed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyStateStructure_SenderChainKey>, I>>(
    base?: I,
  ): SenderKeyStateStructure_SenderChainKey {
    return SenderKeyStateStructure_SenderChainKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyStateStructure_SenderChainKey>, I>>(
    object: I,
  ): SenderKeyStateStructure_SenderChainKey {
    const message = createBaseSenderKeyStateStructure_SenderChainKey();
    message.iteration = object.iteration ?? undefined;
    message.seed = object.seed ?? undefined;
    return message;
  },
};

function createBaseSenderKeyStateStructure_SenderMessageKey(): SenderKeyStateStructure_SenderMessageKey {
  return { iteration: undefined, seed: undefined };
}

export const SenderKeyStateStructure_SenderMessageKey: MessageFns<SenderKeyStateStructure_SenderMessageKey> = {
  encode(message: SenderKeyStateStructure_SenderMessageKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iteration !== undefined) {
      writer.uint32(8).uint32(message.iteration);
    }
    if (message.seed !== undefined) {
      writer.uint32(18).bytes(message.seed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyStateStructure_SenderMessageKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyStateStructure_SenderMessageKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iteration = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seed = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyStateStructure_SenderMessageKey {
    return {
      iteration: isSet(object.iteration) ? globalThis.Number(object.iteration) : undefined,
      seed: isSet(object.seed) ? bytesFromBase64(object.seed) : undefined,
    };
  },

  toJSON(message: SenderKeyStateStructure_SenderMessageKey): unknown {
    const obj: any = {};
    if (message.iteration !== undefined) {
      obj.iteration = Math.round(message.iteration);
    }
    if (message.seed !== undefined) {
      obj.seed = base64FromBytes(message.seed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyStateStructure_SenderMessageKey>, I>>(
    base?: I,
  ): SenderKeyStateStructure_SenderMessageKey {
    return SenderKeyStateStructure_SenderMessageKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyStateStructure_SenderMessageKey>, I>>(
    object: I,
  ): SenderKeyStateStructure_SenderMessageKey {
    const message = createBaseSenderKeyStateStructure_SenderMessageKey();
    message.iteration = object.iteration ?? undefined;
    message.seed = object.seed ?? undefined;
    return message;
  },
};

function createBaseSenderKeyStateStructure_SenderSigningKey(): SenderKeyStateStructure_SenderSigningKey {
  return { public: undefined, private: undefined };
}

export const SenderKeyStateStructure_SenderSigningKey: MessageFns<SenderKeyStateStructure_SenderSigningKey> = {
  encode(message: SenderKeyStateStructure_SenderSigningKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.public !== undefined) {
      writer.uint32(10).bytes(message.public);
    }
    if (message.private !== undefined) {
      writer.uint32(18).bytes(message.private);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyStateStructure_SenderSigningKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyStateStructure_SenderSigningKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.public = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.private = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyStateStructure_SenderSigningKey {
    return {
      public: isSet(object.public) ? bytesFromBase64(object.public) : undefined,
      private: isSet(object.private) ? bytesFromBase64(object.private) : undefined,
    };
  },

  toJSON(message: SenderKeyStateStructure_SenderSigningKey): unknown {
    const obj: any = {};
    if (message.public !== undefined) {
      obj.public = base64FromBytes(message.public);
    }
    if (message.private !== undefined) {
      obj.private = base64FromBytes(message.private);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyStateStructure_SenderSigningKey>, I>>(
    base?: I,
  ): SenderKeyStateStructure_SenderSigningKey {
    return SenderKeyStateStructure_SenderSigningKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyStateStructure_SenderSigningKey>, I>>(
    object: I,
  ): SenderKeyStateStructure_SenderSigningKey {
    const message = createBaseSenderKeyStateStructure_SenderSigningKey();
    message.public = object.public ?? undefined;
    message.private = object.private ?? undefined;
    return message;
  },
};

function createBaseSenderKeyRecordStructure(): SenderKeyRecordStructure {
  return { senderKeyStates: [] };
}

export const SenderKeyRecordStructure: MessageFns<SenderKeyRecordStructure> = {
  encode(message: SenderKeyRecordStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.senderKeyStates) {
      SenderKeyStateStructure.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyRecordStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyRecordStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.senderKeyStates.push(SenderKeyStateStructure.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyRecordStructure {
    return {
      senderKeyStates: globalThis.Array.isArray(object?.senderKeyStates)
        ? object.senderKeyStates.map((e: any) => SenderKeyStateStructure.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SenderKeyRecordStructure): unknown {
    const obj: any = {};
    if (message.senderKeyStates?.length) {
      obj.senderKeyStates = message.senderKeyStates.map((e) => SenderKeyStateStructure.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyRecordStructure>, I>>(base?: I): SenderKeyRecordStructure {
    return SenderKeyRecordStructure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyRecordStructure>, I>>(object: I): SenderKeyRecordStructure {
    const message = createBaseSenderKeyRecordStructure();
    message.senderKeyStates = object.senderKeyStates?.map((e) => SenderKeyStateStructure.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
