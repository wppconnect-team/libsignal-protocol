// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: WhisperTextProtocol.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export interface SignalMessage {
  ratchetKey?: Uint8Array | undefined;
  counter?: number | undefined;
  previousCounter?: number | undefined;
  ciphertext?: Uint8Array | undefined;
}

export interface PreKeySignalMessage {
  registrationId?: number | undefined;
  preKeyId?: number | undefined;
  signedPreKeyId?: number | undefined;
  baseKey?: Uint8Array | undefined;
  identityKey?:
    | Uint8Array
    | undefined;
  /** SignalMessage */
  message?: Uint8Array | undefined;
}

export interface KeyExchangeMessage {
  id?: number | undefined;
  baseKey?: Uint8Array | undefined;
  ratchetKey?: Uint8Array | undefined;
  identityKey?: Uint8Array | undefined;
  baseKeySignature?: Uint8Array | undefined;
}

export interface SenderKeyMessage {
  id?: number | undefined;
  iteration?: number | undefined;
  ciphertext?: Uint8Array | undefined;
}

export interface SenderKeyDistributionMessage {
  id?: number | undefined;
  iteration?: number | undefined;
  chainKey?: Uint8Array | undefined;
  signingKey?: Uint8Array | undefined;
}

export interface DeviceConsistencyCodeMessage {
  generation?: number | undefined;
  signature?: Uint8Array | undefined;
}

function createBaseSignalMessage(): SignalMessage {
  return { ratchetKey: undefined, counter: undefined, previousCounter: undefined, ciphertext: undefined };
}

export const SignalMessage: MessageFns<SignalMessage> = {
  encode(message: SignalMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ratchetKey !== undefined) {
      writer.uint32(10).bytes(message.ratchetKey);
    }
    if (message.counter !== undefined) {
      writer.uint32(16).uint32(message.counter);
    }
    if (message.previousCounter !== undefined) {
      writer.uint32(24).uint32(message.previousCounter);
    }
    if (message.ciphertext !== undefined) {
      writer.uint32(34).bytes(message.ciphertext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ratchetKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.counter = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.previousCounter = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalMessage {
    return {
      ratchetKey: isSet(object.ratchetKey) ? bytesFromBase64(object.ratchetKey) : undefined,
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : undefined,
      previousCounter: isSet(object.previousCounter) ? globalThis.Number(object.previousCounter) : undefined,
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : undefined,
    };
  },

  toJSON(message: SignalMessage): unknown {
    const obj: any = {};
    if (message.ratchetKey !== undefined) {
      obj.ratchetKey = base64FromBytes(message.ratchetKey);
    }
    if (message.counter !== undefined) {
      obj.counter = Math.round(message.counter);
    }
    if (message.previousCounter !== undefined) {
      obj.previousCounter = Math.round(message.previousCounter);
    }
    if (message.ciphertext !== undefined) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalMessage>, I>>(base?: I): SignalMessage {
    return SignalMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalMessage>, I>>(object: I): SignalMessage {
    const message = createBaseSignalMessage();
    message.ratchetKey = object.ratchetKey ?? undefined;
    message.counter = object.counter ?? undefined;
    message.previousCounter = object.previousCounter ?? undefined;
    message.ciphertext = object.ciphertext ?? undefined;
    return message;
  },
};

function createBasePreKeySignalMessage(): PreKeySignalMessage {
  return {
    registrationId: undefined,
    preKeyId: undefined,
    signedPreKeyId: undefined,
    baseKey: undefined,
    identityKey: undefined,
    message: undefined,
  };
}

export const PreKeySignalMessage: MessageFns<PreKeySignalMessage> = {
  encode(message: PreKeySignalMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registrationId !== undefined) {
      writer.uint32(40).uint32(message.registrationId);
    }
    if (message.preKeyId !== undefined) {
      writer.uint32(8).uint32(message.preKeyId);
    }
    if (message.signedPreKeyId !== undefined) {
      writer.uint32(48).uint32(message.signedPreKeyId);
    }
    if (message.baseKey !== undefined) {
      writer.uint32(18).bytes(message.baseKey);
    }
    if (message.identityKey !== undefined) {
      writer.uint32(26).bytes(message.identityKey);
    }
    if (message.message !== undefined) {
      writer.uint32(34).bytes(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeySignalMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeySignalMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.registrationId = reader.uint32();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.preKeyId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.signedPreKeyId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identityKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeySignalMessage {
    return {
      registrationId: isSet(object.registrationId) ? globalThis.Number(object.registrationId) : undefined,
      preKeyId: isSet(object.preKeyId) ? globalThis.Number(object.preKeyId) : undefined,
      signedPreKeyId: isSet(object.signedPreKeyId) ? globalThis.Number(object.signedPreKeyId) : undefined,
      baseKey: isSet(object.baseKey) ? bytesFromBase64(object.baseKey) : undefined,
      identityKey: isSet(object.identityKey) ? bytesFromBase64(object.identityKey) : undefined,
      message: isSet(object.message) ? bytesFromBase64(object.message) : undefined,
    };
  },

  toJSON(message: PreKeySignalMessage): unknown {
    const obj: any = {};
    if (message.registrationId !== undefined) {
      obj.registrationId = Math.round(message.registrationId);
    }
    if (message.preKeyId !== undefined) {
      obj.preKeyId = Math.round(message.preKeyId);
    }
    if (message.signedPreKeyId !== undefined) {
      obj.signedPreKeyId = Math.round(message.signedPreKeyId);
    }
    if (message.baseKey !== undefined) {
      obj.baseKey = base64FromBytes(message.baseKey);
    }
    if (message.identityKey !== undefined) {
      obj.identityKey = base64FromBytes(message.identityKey);
    }
    if (message.message !== undefined) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeySignalMessage>, I>>(base?: I): PreKeySignalMessage {
    return PreKeySignalMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeySignalMessage>, I>>(object: I): PreKeySignalMessage {
    const message = createBasePreKeySignalMessage();
    message.registrationId = object.registrationId ?? undefined;
    message.preKeyId = object.preKeyId ?? undefined;
    message.signedPreKeyId = object.signedPreKeyId ?? undefined;
    message.baseKey = object.baseKey ?? undefined;
    message.identityKey = object.identityKey ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseKeyExchangeMessage(): KeyExchangeMessage {
  return {
    id: undefined,
    baseKey: undefined,
    ratchetKey: undefined,
    identityKey: undefined,
    baseKeySignature: undefined,
  };
}

export const KeyExchangeMessage: MessageFns<KeyExchangeMessage> = {
  encode(message: KeyExchangeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.baseKey !== undefined) {
      writer.uint32(18).bytes(message.baseKey);
    }
    if (message.ratchetKey !== undefined) {
      writer.uint32(26).bytes(message.ratchetKey);
    }
    if (message.identityKey !== undefined) {
      writer.uint32(34).bytes(message.identityKey);
    }
    if (message.baseKeySignature !== undefined) {
      writer.uint32(42).bytes(message.baseKeySignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyExchangeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyExchangeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ratchetKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.identityKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.baseKeySignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyExchangeMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      baseKey: isSet(object.baseKey) ? bytesFromBase64(object.baseKey) : undefined,
      ratchetKey: isSet(object.ratchetKey) ? bytesFromBase64(object.ratchetKey) : undefined,
      identityKey: isSet(object.identityKey) ? bytesFromBase64(object.identityKey) : undefined,
      baseKeySignature: isSet(object.baseKeySignature) ? bytesFromBase64(object.baseKeySignature) : undefined,
    };
  },

  toJSON(message: KeyExchangeMessage): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.baseKey !== undefined) {
      obj.baseKey = base64FromBytes(message.baseKey);
    }
    if (message.ratchetKey !== undefined) {
      obj.ratchetKey = base64FromBytes(message.ratchetKey);
    }
    if (message.identityKey !== undefined) {
      obj.identityKey = base64FromBytes(message.identityKey);
    }
    if (message.baseKeySignature !== undefined) {
      obj.baseKeySignature = base64FromBytes(message.baseKeySignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyExchangeMessage>, I>>(base?: I): KeyExchangeMessage {
    return KeyExchangeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyExchangeMessage>, I>>(object: I): KeyExchangeMessage {
    const message = createBaseKeyExchangeMessage();
    message.id = object.id ?? undefined;
    message.baseKey = object.baseKey ?? undefined;
    message.ratchetKey = object.ratchetKey ?? undefined;
    message.identityKey = object.identityKey ?? undefined;
    message.baseKeySignature = object.baseKeySignature ?? undefined;
    return message;
  },
};

function createBaseSenderKeyMessage(): SenderKeyMessage {
  return { id: undefined, iteration: undefined, ciphertext: undefined };
}

export const SenderKeyMessage: MessageFns<SenderKeyMessage> = {
  encode(message: SenderKeyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.iteration !== undefined) {
      writer.uint32(16).uint32(message.iteration);
    }
    if (message.ciphertext !== undefined) {
      writer.uint32(26).bytes(message.ciphertext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.iteration = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      iteration: isSet(object.iteration) ? globalThis.Number(object.iteration) : undefined,
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : undefined,
    };
  },

  toJSON(message: SenderKeyMessage): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.iteration !== undefined) {
      obj.iteration = Math.round(message.iteration);
    }
    if (message.ciphertext !== undefined) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyMessage>, I>>(base?: I): SenderKeyMessage {
    return SenderKeyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyMessage>, I>>(object: I): SenderKeyMessage {
    const message = createBaseSenderKeyMessage();
    message.id = object.id ?? undefined;
    message.iteration = object.iteration ?? undefined;
    message.ciphertext = object.ciphertext ?? undefined;
    return message;
  },
};

function createBaseSenderKeyDistributionMessage(): SenderKeyDistributionMessage {
  return { id: undefined, iteration: undefined, chainKey: undefined, signingKey: undefined };
}

export const SenderKeyDistributionMessage: MessageFns<SenderKeyDistributionMessage> = {
  encode(message: SenderKeyDistributionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.iteration !== undefined) {
      writer.uint32(16).uint32(message.iteration);
    }
    if (message.chainKey !== undefined) {
      writer.uint32(26).bytes(message.chainKey);
    }
    if (message.signingKey !== undefined) {
      writer.uint32(34).bytes(message.signingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderKeyDistributionMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderKeyDistributionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.iteration = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderKeyDistributionMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      iteration: isSet(object.iteration) ? globalThis.Number(object.iteration) : undefined,
      chainKey: isSet(object.chainKey) ? bytesFromBase64(object.chainKey) : undefined,
      signingKey: isSet(object.signingKey) ? bytesFromBase64(object.signingKey) : undefined,
    };
  },

  toJSON(message: SenderKeyDistributionMessage): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.iteration !== undefined) {
      obj.iteration = Math.round(message.iteration);
    }
    if (message.chainKey !== undefined) {
      obj.chainKey = base64FromBytes(message.chainKey);
    }
    if (message.signingKey !== undefined) {
      obj.signingKey = base64FromBytes(message.signingKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderKeyDistributionMessage>, I>>(base?: I): SenderKeyDistributionMessage {
    return SenderKeyDistributionMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderKeyDistributionMessage>, I>>(object: I): SenderKeyDistributionMessage {
    const message = createBaseSenderKeyDistributionMessage();
    message.id = object.id ?? undefined;
    message.iteration = object.iteration ?? undefined;
    message.chainKey = object.chainKey ?? undefined;
    message.signingKey = object.signingKey ?? undefined;
    return message;
  },
};

function createBaseDeviceConsistencyCodeMessage(): DeviceConsistencyCodeMessage {
  return { generation: undefined, signature: undefined };
}

export const DeviceConsistencyCodeMessage: MessageFns<DeviceConsistencyCodeMessage> = {
  encode(message: DeviceConsistencyCodeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generation !== undefined) {
      writer.uint32(8).uint32(message.generation);
    }
    if (message.signature !== undefined) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceConsistencyCodeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceConsistencyCodeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.generation = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceConsistencyCodeMessage {
    return {
      generation: isSet(object.generation) ? globalThis.Number(object.generation) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : undefined,
    };
  },

  toJSON(message: DeviceConsistencyCodeMessage): unknown {
    const obj: any = {};
    if (message.generation !== undefined) {
      obj.generation = Math.round(message.generation);
    }
    if (message.signature !== undefined) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeviceConsistencyCodeMessage>, I>>(base?: I): DeviceConsistencyCodeMessage {
    return DeviceConsistencyCodeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeviceConsistencyCodeMessage>, I>>(object: I): DeviceConsistencyCodeMessage {
    const message = createBaseDeviceConsistencyCodeMessage();
    message.generation = object.generation ?? undefined;
    message.signature = object.signature ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
